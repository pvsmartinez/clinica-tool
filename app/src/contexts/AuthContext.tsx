import { createContext, useContext, useEffect, useState } from 'react'
import type { Session } from '@supabase/supabase-js'
import { supabase } from '../services/supabase'
import { primaryRole, mergedPermissions } from '../types'
import type { UserProfile, UserRole } from '../types'

interface AuthContextValue {
  session: Session | null
  profile: UserProfile | null
  role: UserRole | null
  isSuperAdmin: boolean
  loading: boolean
  recoveryMode: boolean
  clearRecoveryMode: () => void
  signInWithEmail: (email: string, password: string) => Promise<{ error: string | null }>
  signInWithGoogle: () => Promise<void>
  signInWithApple: () => Promise<void>
  signOut: () => Promise<void>
  hasPermission: (key: string) => boolean
}

const AuthContext = createContext<AuthContextValue | null>(null)

const PROFILE_CACHE_KEY = 'consultin_profile_cache'

function getCachedProfile(): UserProfile | null {
  try {
    const raw = localStorage.getItem(PROFILE_CACHE_KEY)
    return raw ? (JSON.parse(raw) as UserProfile) : null
  } catch { return null }
}

function setCachedProfile(p: UserProfile | null) {
  try {
    if (p) localStorage.setItem(PROFILE_CACHE_KEY, JSON.stringify(p))
    else localStorage.removeItem(PROFILE_CACHE_KEY)
  } catch { /* ignore */ }
}

async function fetchProfile(userId: string): Promise<UserProfile | null> {
  const timeout = new Promise<null>((_, reject) =>
    setTimeout(() => reject(new Error('fetchProfile timeout')), 4000)
  )
  const query = supabase
    .from('user_profiles')
    .select('id, clinic_id, roles, name, is_super_admin')
    .eq('id', userId)
    .single()
    .then(({ data }) => {
      if (!data) return null
      return {
        id: data.id as string,
        clinicId: data.clinic_id as string | null,
        roles: (data.roles as UserRole[]) ?? [],
        name: data.name as string,
        isSuperAdmin: (data.is_super_admin as boolean) ?? false,
      } as UserProfile
    })
  return Promise.race([query, timeout])
}

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [session, setSession] = useState<Session | null>(null)
  // Seed profile from cache so UI renders instantly on reload
  const [profile, setProfile] = useState<UserProfile | null>(getCachedProfile)
  const [loading, setLoading] = useState(true)
  // True when Supabase fires PASSWORD_RECOVERY — forces NovaSenhaPage regardless of route
  const [recoveryMode, setRecoveryMode] = useState(false)

  useEffect(() => {
    let settled = false

    const settle = () => {
      settled = true
      clearTimeout(timeout)
    }

    // Safety net: if auth never resolves (token refresh hang, network issue),
    // clear state and show login after 3s. Do NOT await signOut — it can hang too.
    const timeout = setTimeout(() => {
      if (settled) return
      console.warn('Auth timed out — clearing session')
      supabase.auth.signOut().catch(() => { /* ignore */ })
      setSession(null)
      setProfile(null)
      setCachedProfile(null)
      setLoading(false)
      settle()
    }, 3000)

    const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event, session) => {
      settle()
      setSession(session)

      // Intercept password-reset flow — show change-password screen immediately
      if (event === 'PASSWORD_RECOVERY') {
        setRecoveryMode(true)
        setLoading(false)
        return
      }

      if (!session) {
        setProfile(null)
        setCachedProfile(null)
        setLoading(false)
        return
      }

      // Use cached profile to render instantly, then refresh from DB in background
      const cached = getCachedProfile()
      if (cached && cached.id === session.user.id) {
        setProfile(cached)
        setLoading(false)
      }

      try {
        const p = await fetchProfile(session.user.id)
        setProfile(p)
        setCachedProfile(p)
      } catch (e) {
        console.error('fetchProfile error:', e)
        if (!cached) { setProfile(null); setCachedProfile(null) }
      } finally {
        setLoading(false) // no-op if already false
      }
    })

    return () => { settle(); subscription.unsubscribe() }
  }, [])

  const signInWithEmail = async (email: string, password: string) => {
    const { error } = await supabase.auth.signInWithPassword({ email, password })
    return { error: error?.message ?? null }
  }

  const signInWithGoogle = () =>
    supabase.auth.signInWithOAuth({ provider: 'google', options: { redirectTo: window.location.origin } }).then(() => undefined)

  const signInWithApple = () =>
    supabase.auth.signInWithOAuth({ provider: 'apple', options: { redirectTo: window.location.origin } }).then(() => undefined)

  const signOut = () => supabase.auth.signOut().then(() => undefined)
  const clearRecoveryMode = () => setRecoveryMode(false)

  const hasPermission = (key: string): boolean => {
    if (!profile) return false
    return mergedPermissions(profile.roles)[key] ?? false
  }

  return (
    <AuthContext.Provider value={{
      session, profile, role: profile ? primaryRole(profile.roles) : null, loading,
      isSuperAdmin: profile?.isSuperAdmin ?? false,
      recoveryMode, clearRecoveryMode,
      signInWithEmail, signInWithGoogle, signInWithApple, signOut, hasPermission,
    }}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuthContext(): AuthContextValue {
  const ctx = useContext(AuthContext)
  if (!ctx) throw new Error('useAuthContext must be used inside <AuthProvider>')
  return ctx
}
